% !TEX root =  ../thesis.tex

Il lavoro presentato in questa tesi è frutto di un progetto di ricerca nell'ambito di copilatori, metodi formali e computer security che ha come obiettivo la definizione ed implementatazione di un ``defensive optimizer compiler'', ovvero un compilatore in grado di attuare ottimizzazioni sul codice sorgente che siano formalmente sicure.

Oggigiorno, i moderni compilatori contengono molteplici complesse e altamanete specifiche ottimizzazioni che concorrono a trasformare un codice sorgente in input in un codice più efficiente e allo stesso tempo equivalente dal punto di vista funzionale. L'efficienza puo essere misurata in termini di velocita di esecuzione, spzio di memoria allocato o consumo energitico della macchina che esegue il programma. Tuttavia questi algoritmi contengono delle euristiche che non sempre sono in grado di estrarre invarianti e proprietà che potrebbero potenzialmente portare a ulteriori ottimizzazioni. Proprietà che, per esempio, necessitano di algoritmi di verifica formale per essere catturate, che possono essere inserite esternalmente, per esempio dal programmatore steso tramite annotazioni sul codice. Inoltre, in domini critici è fondamentale che la trasformazione effettuata dal compilatore non modifichi il comportamento del programma per ogni possibile input.

Questa tesi presenta un framework che permette di costruire ottimizzazion che sono capaci di sfruttare queste annotazioni per ottimizzare ulteriormente il codice, e assicura che dette trasformazioni siano formalmente corrette. Il framework è implementato per essere usato con il compilatore \emph{Low Level Virtual Machine} (\emph{LLVM}) \cite{lattner2002llvm}, un compilatore-infrastruttura caratterizzato da un alto livello di modularità e riusabilità.\

Prima di tutto, viene fornita un'introduzione al problema, e un approccio teorico per la soluzione. Viene mostrato come la soluzione può avere differenti design e implementazione usando l'infrastruttura offerta da LLVM. Per dimostrare la correttezza di queste trasformazioni e fornire un metodo per trasportare gli invarianti e le proprietà attraverso i differenti passi di ottimizzazione, un ``witness'', o testimone, viene generato per ogni trasformazione. Il witness puo' essere verificato indipendentemente da un sistema di risoluzione teoremi per stabilire la correttezza della trasformazione e, se corretta, aiutare a trasferire gli invarianti dal codice di input a quello di output della trasformazione. La tesi presenta l'implementazione dello witness per alcune famose e comuni trasformazioni.
